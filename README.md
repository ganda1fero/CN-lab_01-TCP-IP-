## Создание последовательного сервера с установлением логического соединения (TCP/IP) ()
### Введение
- [!] *internetworking* - технология межсетевого обмена (позволяет взаимно соединять различные сети)
- [!] *TCP/IP* - (Связка Межсетевых Протоколов) 
##### Отличие TCP/IP от других протоколов:
1) **НЕЗАВИСИМОСТЬ ОТ СЕТЕВОЙ ТЕХНОЛОГИИ** - он независим от оборудования конкретного производителя. Протоколы TCP/IP определяют элемент передачи данных, называемый *дейтаграммой*, и описывают, как передавать дейтаграммы по конкретной сети.
2) **ВСЕОБЩАЯ СВЯЗНОСТЬ** - Каждому компьютеру *назначается адрес*, который известен по всему Интернету. Каждая дейтаграмма содержит *адреса отправителя и получателя*. Промежуточные маршрутизаторы используют адрес получателя для того, чтобы принимать решение о дальнейшем маршруте дейтаграммы.
3) **МЕЖКОНЦЕВЫЕ ПОДТВЕРЖДЕНИЯ** - Протоколы TCP/IP Интернета обеспечивают *подтверждения между отправителем и получателем*, а не между отправителем и промежуточными машинами на пути.
4) **СТАНДАРТНЫЕ ПРИКЛАДНЫЕ ПРОТОКОЛЫ** - протоколы TCP/IP *включают стандарты* для наиболее часто используемых приложений, таких как электронная почта, передача файлов и удаленный доступ.
##### На сетевом уровне Интернет предоставляет два основных типа сервиса, который используют прикладные программы:
1) **ДЕЙТАГРАММНОЕ СРЕДСТВО ДОСТАВКИ ПАКЕТОВ *(UDP)*,** - будет рассмотрено во второй лабораторной работе данного пособия.
2) **НАДЕЖНОЕ ПОТОКОВОЕ ТРАНСПОРТНОЕ СРЕДСТВО *(TCP)*** - Обеспечивает *автоматическое восстановление при ошибках передачи*, потере пакетов или сбоях промежуточных маршрутизаторов на пути между отправителем и получателем. Оно позволяет приложению на одном компьютере устанавливать "соединение" с приложением на другом компьютере, а затем посылать большие объемы данных по соединению, как если бы это было прямое аппаратное соединение. На самом деле, конечно, *протоколы взаимодействия делят поток данных на маленькие сообщения и посылают их затем по одному, ожидая от получателя подтверждения приема*.
### Методические указания по реализации соединения (клиент-сервер) с помощью протокола TCP/IP
##### СЕРВЕРНАЯ ЧАСТЬ
###### "Развертывание сервера"
1) При разработке приложений для клиента и сервера для обмена структурами данных или пакетами используются *сокеты*. **Сокет** – это абстрактный объект для обозначения одного из концов сетевого соединения. Реализация сокетов осуществляется *в API WinSock*.
- [!] Библиотеку необходимо подключить к проекту, выполненному в VC++: _Project –>Settings – вкладка Links_ – к списку подключаемых библиотек через пробел добавляем _ws2_32.lib_. В тексте программы этот интерфейс разработки приложений подключается с помощью директивы (#include): *(#include) <winsock2.h>*.
- [!] Для того чтобы  можно было использовать WinSock API, он должен быть инициализирован. Это делается с помощью функции *WSAStartup(wVersionRequested,&wsaData)*. Где первый параметр функции *WSAStartup ( )* — это значение типа *word*, которое определяет максимальный номер версии WinSock, доступный приложению. Функция _WSAStartup_ _( )_ возвращает значение _wsasysnotready_, если динамическая библиотека под­держки WinSock или соответствующая подсистема сети не инициализирована. Второй параметр – структура _wsaData_ – содержит номер версии, которая должна использоваться (поле wVersion), максимальный номер версии, поддерживаемый данной библиотекой (поле wHighVersion), текстовые строки с описанием реализации WinSock, максимальное число сокетов, доступных процессу и максимально допустимый размер дейтаграмм.
```cpp
int main(){
     WORD wVersionRequested;
     WSADATA wsaData;
     wVersionRequested = MAKEWORD(2,2);
     WSAStartup(wVersionRequested,&wsaData);
```
- [!] Для создания сокета используется функция *socket(domain,type,protocol)*. Она принимает три параметра: домен, тип сокета и протокол. Домен – это абстракция, подразумевающая конкретную структуру адресации и протоколы, определяющие типы сокетов внутри домена. Примерами коммуникационных доменов могут быть: UNIX домен, Internet домен, и т.д. В Internet домене сокет - это комбинация IP адреса и номера порта, которая однозначно определяет отдельный сетевой процесс во всей глобальной сети Internet.

Вызов функции _socket( )_ выглядит следующим образом:
```cpp
SOCKET s = socket(AF_INET, SOCK_STREAM, 0);
```
Первый параметр означает, что с этим сокетом будут использоваться адреса Internet; следующие два аргумента задают тип создаваемого сокета и протокол обмена данными через него. В приве­денном примере создается сокет потока, использую­щий протокол TCP.

Если третий параметр функции _socket( )_ сделать равным нулю, протокол будет выбран автоматически в зависимости, от семейства адресов и типа сокета. Можно явно указать константы:
1) IPPROTO_UDP – протокол UDP (лаб. раб. №2).
2) IPPROTO_TCP – протокол TCP/IP.
- [!] Если функция _socket( )_ выполняется успешно, она возвращает дескриптор нового сокета "*SOCKET* (ненулевое значение-дескриптор)". Если же ее работа завершается аварийно, возвращается значение "*INVALID_SOCKET*" ("-1") , и для получения подробной информации об ( ошибке необходимо вызвать функцию *WSAGetLastError( )*.

Для связывания конкретного адреса с сокетом используется функция **_bind_ _(s,_ _addr, addrlen)_**. В нее передается дескриптор сокета, указатель на структуру адреса и длина этой структуры. Дескриптор сокета – это значение, которое возвращает функция _socket( )_. Структура адреса –это структура типа _sockaddr_in_. ***bind(s, addr, addrlen)*** возвращает *0* при успехе и `SOCKET_ERROR` (*-1*) при ошибке.
```cpp
sockaddr_in local;
local.sin_family = AF_INET;
local.sin_port = htons(1280);
local.sin_addr.s_addr = htonl(INADDR_ANY);

if (bind(s, (sockaddr*)&local, sizeof(local)) == SOCKET_ERROR) {
    int err = WSAGetLastError();
} 
else {
    // все хорошо - продолжаем
}
```
- [!] В поле *sin_addr* структуры *sockaddr_in* хранится *физический IP-адрес компьютера* в формате структуры *in_addr*, описанной в заголовочном файле winsock2.h. Вместо поля s_addr можно подставлять *INADDR_ANY*. это позволяет сокету посылать или принимать данные через *любой IP-адрес данного компьютера*. Обычно компьютер имеет только один IP-адрес, хотя, в принципе, на нем может быть установлено несколько сетевых адаптеров, каждый со своим IP-адресом. *Если сокет должен использовать только один из них, его необходимо указать явно*. Для этого нередко используется функция *inet_addr(“…” )*, которая принимает в качеств аргумента ASCII-строку десятичной нотации IP-адреса с точкой и возвращает переменную типа *u_long*, содержащую этот адрес в формате поля *s_addr*. Кроме нее, существует функция _inet_ntoa(__address__),_ которая выполняет обратное преобразование, принимая переменную типа *u_long* и возвращая адрес в виде ASCII-строки.
- [!] Поле _sin_family_ всегда имеет значение _AF_INET_. 
- [!] Поле _sin_port_ определяет порт, который будет ассоциирован с сокетом.

*Для привязки* приложение может использовать любой *номер порта от 1 до 65535*, хотя этот диапазон обычно делится на следующие поддиапазоны:
1) *0* – нe используется. Если передать 0 в качестве номера порта, будет автоматически выбран  используемый порт с номером между 1 024 и 5 000.
2) *1 – 255* – зарезервированы для сетевых служб: FTP, telnet, finger и т.д.
3) *256 – 1 023* – зарезервированы для других служб общего назначения, например функций маршрутизации.
4) *1024 – 4999* – служат для портов клиентов. *Обычно сокеты приложений-клиентов* используют номера портов именно из этого диапазона.
5) *5000 – 65535*. Используются для определяемых пользователем п*ортов приложений-серверов*.

Вместо простого присвоения констант полей _sin_port_ и _sin_addr_ использовалось преобразование типов с помощью функций *htons(n)* и *htonl(n)* Эти функции предназначены для изменения порядка следования байтов в параметрах порта и адреса, для преобразования их в общий сетевой формат для 16-разрядных и 32-разрядных значений соответственно.
###### "Использование сервера" 
После создания сокета и привязки его к адресу необходимо каким-то образом установить соединение с клиентом. Для этого используется функция *listen (s,l)* , которая помещает сокет  в состояние прослушивания. Вызывать *listen(s,l)* нужно всего *РАЗ* т.к. это всего лишь команда ОС стеку того, чтобы он перевел сокет в режим прослушивания.
```cpp
int r = listen(s,5);
```
- [!] Вызов этой функции инициализирует ожидание выбранного дескриптора *s*, выставляя максимальное количество "висящих" соединений *l*. Если клиент попробует присоединиться к серверу (создать соединение), но *l* уже будет заполнено, то пользовать, при вызове *connect()* получит *WSAECONNREFUSED* в *WSA*. Сам по себе механизм должен принудительно предотвращать DOS/DDOS атаки, направленные на переполнение *SYN - запрос на подключение* для невозможности подключения другим пользователям (сервер "ложится, не отвечает"). Данная функция возвращает *int* - код выполнения (*0* - успешный вызов, все окей: *-1* - ошибка, для более подробной информации необходимо вызвать *WSAGetLastError()* (выдаст более подробный код ошибки, например `WSAEADDRINUSE` — порт уже занят). 

При получении запроса клиента, открытие соединения выполняется с помощью функции *accept()*
```cpp
SOCKET accept (SOCKET s, struct sockaddr FAR * addr, int FAR* addrlen);
```
Как обычно, в качестве первого параметра передается сокет *s*, ожидающий запроса. Второй и третий па­раметры *используются для получения адреса сокета клиента*, который запрашивает соединение. Если соединение открывается успешно, функция accept() *возвращает дескриптор на новый сокет* (на том же ID/порт создается новый сокет, но уже с парой физ. IP:порт (сервер) и удаленным IP:порт (клиент)), ко­торый будет использоваться для управления новым соединением. Если произошла ошибка, функция ac­cept() возвращает код *invalid_socket*, и для получения более подробной информации об ошибке не­обходимо вызвать функцию WSAGetLastError().
На нашем примере это выглядит так:
```cpp
sockaddr_in remote_addr;
int size = sizeof(remote_addr);

SOCKET s2 = accept(s, (sockaddr*)&remote_addr, &size);
if (s2 == INVALID_SOCKET) {
    // ошибка
    int err = WSAGetLastError();
} else {
    // здесь можно работать с клиентом через s2
}
```

Для приема данных через сокет потока используется функция *recv()*. Вот ее прототип: 
```cpp
int recv (SOCKET s, char FAR* buf, int len, int flags);
```
Параметры _buf_ и _len_ определяют соответственно буфер для приема данных и его длину. Параметр *flags* может принимать значения `MSG_OOB` для приема привилегированных данных или `MSG_PEEK` для за­полнения буфера без удаления данных из входной очереди, но, как правило, мы пишем его равным *нулю*.
- [!] Если во входной очереди находятся данные для сокета, функция _recv()_ возвращает количество *реально прочи­танных байтов*, которое не превосходит значения *len*. *При корректном закрытии соединения возвращается значение 0*, а при аварийном – значение *SOCKET_ERROR*. Для определения точного кода ошибки необходимо вызвать функцию *WSAGetLastError()*. Однако если соединение не закрыто, но буфер приема закончился, то программа "остановится" на *recv()*. *recv() блокируется (ждет новые данные)*. 

Пересылка данных выпол­няется с помощью функции *send()*:
```cpp
int send (SOCKET s, const char FAR *buf, int len, int flags);
```
Функция _send( )_ принимает в качестве аргументов указатель на буфер, содержащий пересылаемые данные, и его длину, а также параметр *flags*. Если этот параметр равен `msg_dontroute`, в пересылаемый набор данных не включается информация о маршрутизации; если его значение равно `msg_oob`, посылает­ся поток привилегированных (out-of-band) данных, однако в 99% случаях будем использовать flag = *0*.
- [!] При вызове *send()* мы передаем наш массив длинной *len* (хоть, например, 1МБ) в буфер отправки, где он *САМ ОПРЕДЕЛИТ* размер пакетов, исходя из сети, который будет равен *MSS* - maximum segment size, зависит от MTU сети. При этом функция возвратит количество реально отправленных байтов, которые могут быть <= len (если байты ушли не все => необходимо дослать эти данные еще раз через *send(s, data + real_len (смещаем указатель байтов до места "обрыва"), len - real_len)*)  

Работу с одним клиентом поместим в цикл, чтобы была возможность вводить несколько строк (*будет выполняться пока есть соединение с клиентов*).
```cpp
char b[1024];   // Буфер на 1КБ
int n;          // для проверки кода recv()

while ((n = recv(s2, b, sizeof(b), 0)) > 0) {  // код -1:ошибка, 0:заверешение соединения => для чтения нас интересует > 0
    int i = 0;
    for (int j = 0; j < n; j++) {   // перебираем до n (реальное число прочитанных байтов)
        if (b[j] == 'a') i++;
    }
    char res[32];
    _itoa(i, res, 10); // переводим int -> string.data() = char[]
    send(s2, res, strlen(res), 0); // отправляем (тут по хорошему сделать проверку на количество отправленных байтов)
}
```
Пример досылки данных, если *send()* вернет число байтов меньше *len*
```cpp
int total = 0;       // количество реально отправленных байтов
while (total < len) {
    int sent = send(sock, buf + total, len - total, 0);
    if (sent == SOCKET_ERROR) { /* ошибка */ break; }  // обязательно обрабатываем ошибки и на этом этапе
    total += sent;
}
// выходим из цикла, если доотправили все или получили ошибку
```
- [!] **ВАЖНО!** *send()* не добавляет символ конца строки '\n', а просто отправляет сырые данные, так что определять конец пересылки (конец пересылаемых данных) нужно самому с помощью внешних протоколов, например, своего протокола (можно просто поставить *'\n'* или *первые 4 байта - u_int32_t, число байтов*)
Пример правильной отправки конца данных:
```cpp
char res[32];
_itoa(i, res, 10);
// Добавим перевод строки в конец
int len = strlen(res); // считает символы до первого '\0'
res[len] = '\n'; // стоял '\0' -> '\n'
res[len + 1] = '\0'; // добавили доп '\0' (сместили его для добавления '\n')
// Отправим только нужные байты (без завершающего '\0')
send(s2, res, len + 1, 0); // отправляем строку + '\n'.
```
###### Закрытие соединения
**Первым** способом закрытия сокета является *closesocket()*. При вызове возвращает *0* при успехе. Вызывая данную функцию мы говорим "все, я закончил с этим сокетом, можно закрывать".
```cpp
int closesocket(SOCKET s);
```
При закрытии через *closesocket(s)* может быть 2 случая:
1) *"корректное закрытие"* Он может попытаться доставить остатки данных (если такие имеются). 
2) Он просто закрывает сокет "моментально". 

Данное поведение *зависит от знач*. `SO_DONTLINGER` и `SO_LINGER`: 
1) **SO_DONTLINGER** = TRUE (обычное поведение, по умолчанию):  
`closesocket()` возвращает немедленно, данные стараются дослаться «в фоне».
2) **SO_LINGER** = TRUE + задержка > 0:  
`closesocket()` блокирует выполнение до тех пор, пока *все данные не дошлются или не истечет timeuot*.
3) **SO_LINGER** = TRUE + задержка = 0:  
немедленное закрытие, данные в буфере просто отбрасываются (грубый разрыв, похоже на RST).

**Вторым** способом закрытия является *shutdown(SOCKET s, int how)*. Позволяет **частично закрыть соединение**, но оставить сокет живым. *shutdown()* удобно использовать, если, например, сервер хочет сказать: «Я закончил отправку, но жду ещё данные от клиента».
```cpp
int shutdown(SOCKET s, int how);
```
Значение `how`:
1) *0* → больше не читаем (`recv` вернёт 0), но можно отправлять;
2) *1* → больше не пишем (`send` вернёт ошибку), но можно читать;
3) *2* → полностью закрываем и чтение, и запись (эквивалент полного FIN).
- [!] *Завершая программу*, нужно прекратить работу с *WinSock DLL*, вызвав функцию:
```cpp
WSACleanup();
```

##### КЛИЕНТСКАЯ ЧАСТЬ
В целом клиентская часть имеет одинаковые части с серверной, но есть и новые части.
**Одинаково**:
1)  *WSAStartup()* / *WSACleanup()*
2) создание сокета *socket()*
3) закрытие сокета *closesocket()*
4) работа через *send()/recv()*

**Нет в клиенте**: 
1) **bind()** (привязка сокета к адресу)
2) **listen()** (переход в режим ожидания подключений)
3) **accept()** (принятие входящего соединения)

**Что нового в клиенте**:
1) **connect()** — запрос на установку соединения с сервером. Параметры `sockaddr` должны совпадать с `bind()` на сервере.
```cpp
int connect(SOCKET s, const struct sockaddr* name, int namelen);
```
1) **`SOCKET s`** - *дескриптор сокета* (полученный из `socket()`), который будет использоваться как клиентский.    
2) **`const struct sockaddr* name`** - *указатель на структуру*, где мы задаём адрес и порт сервера.      На практике почти всегда приводим `sockaddr_in` к `sockaddr*`:
```cpp
sockaddr_in peer;
peer.sin_family = AF_INET;
peer.sin_port = htons(1280);
peer.sin_addr.s_addr = inet_addr("127.0.0.1");

connect(s, (sockaddr*)&peer, sizeof(peer));
```
3)  **`int namelen`** - *размер структуры* (обычно `sizeof(peer)`).